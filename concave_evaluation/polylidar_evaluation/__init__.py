import time
import logging
from os import path
from pathlib import Path
from shapely.geometry import Polygon, MultiPolygon
from polylidar import extractPolygons, extractPolygonsAndTimings
import numpy as np
from concave_evaluation.helpers import get_poly_coords, save_shapely, modified_fname, load_polygon, evaluate_l2
from concave_evaluation import DEFAULT_PL_SAVE_DIR

logger = logging.getLogger("Concave")


def convert_to_shapely_polygons(polygons, points, return_first=False):
    """Converts a list of C++ polygon to shapely polygon
    If more than one polygon is returned turn into a MultiPolygon
    unless return_first is set
    """
    polygons.sort(key=lambda poly: len(poly.shell), reverse=True)
    if not polygons:
        logger.warn("No polygons returned")
        return None
    if len(polygons) > 1:
        pass
        #logger.info("More than one polygon returned")
    shapely_polygons = []
    for poly in polygons:
        shell_coords = get_poly_coords(poly.shell, points)
        hole_coords = [get_poly_coords(hole, points) for hole in poly.holes]
        poly_shape = Polygon(shell=shell_coords, holes=hole_coords)
        if hole_coords:
            pass
            #logger.info("Holes inside the polygon")
        if not poly_shape.is_valid:
            logger.warn("Invalid Polygon Generated by polylidar")
            continue
        shapely_polygons.append(poly_shape)

    # Return only the largest polygon (the "best")
    if shapely_polygons and return_first:
        return shapely_polygons[0]

    # Check if a multipolygon
    if len(shapely_polygons) == 1:
        return shapely_polygons[0]
    elif len(shapely_polygons) > 1:
        return MultiPolygon(shapely_polygons)
    else:
        # Whoa nothing inside!
        logger.error("No polygons returned for polylidar")
        raise ValueError("No polygons returned for polylidar")

    return shapely_polygons


def get_polygon(points, noise=2.0, alpha=0.0, xyThresh=0.0, add_noise=False, **kwargs):
    if add_noise:
        points = points + np.random.randn(points.shape[0], 2) * noise

    polylidar_kwargs = {"alpha": alpha, 'xyThresh': xyThresh}
    # Timing should start here
    # t0 = time.time()
    polygons, timings = extractPolygonsAndTimings(points, **polylidar_kwargs)
    # end = (time.time() - t0) * 1000
    # Timing should end here
    polygons = convert_to_shapely_polygons(
        polygons, points, return_first=False)
    return polygons, timings


def run_test(point_fpath, save_dir=DEFAULT_PL_SAVE_DIR, n=1, alpha=0.0, xyThresh=10, save_poly=True, gt_fpath=None, **kwargs):
    # Choose alpha parameter or xyThresh
    if alpha > 0:
        xyThresh = 0.0
    # If we already passed in a numpy array, no need to load from file
    if isinstance(point_fpath, np.ndarray):
        points = point_fpath
    else:
        points = np.loadtxt(point_fpath)
    time_ms = []
    for i in range(n):
        polygons, ms = get_polygon(
            points, alpha=alpha, xyThresh=xyThresh, **kwargs)
        time_ms.append(ms)

    if save_poly:
        save_fname, _ = modified_fname(point_fpath, save_dir)
        save_shapely(polygons, save_fname, alg='polylidar')
    
    l2_norm = np.NaN
    # Evaluate L2 Norm if we have the ground truth data
    # if the path is a string (nominal) then load the polygon
    if isinstance(gt_fpath, str):
        gt_shape, _ = load_polygon(gt_fpath)
        l2_norm = evaluate_l2(gt_shape, polygons)
    elif gt_fpath is not None:
        gt_shape = gt_fpath
        l2_norm = evaluate_l2(gt_shape, polygons)

    return polygons, time_ms, l2_norm
